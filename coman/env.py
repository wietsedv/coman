from collections import OrderedDict
from distutils.version import LooseVersion
import hashlib
import json
import os
from pathlib import Path
import re
import subprocess
import sys
from glob import glob
from typing import Any, Dict, Iterator, List, Optional
import click

import ruamel.yaml as yaml

from conda_lock.conda_lock import create_lockfile_from_spec
from conda_lock.src_parser import LockSpecification

from coman.spec import (conda_lock_file, conda_outdated, edit_spec_file, conda_lock_hash, pip_lock_file, pip_lock_hash,
                        pip_outdated, require_spec_file, spec_channels, spec_file, spec_package_names,
                        spec_pip_requirements, spec_platforms)
from coman.system import (env_prefix, pypi_pkg_info, run_exe, system_exe)


def env_python_exe():
    return env_prefix() / "bin" / "python"


def env_python_version():
    vstring = subprocess.check_output([env_python_exe(), "--version"], encoding="utf-8").split(" ")[-1].strip()
    return LooseVersion(vstring)


def filter_platform_selectors(content: str, platform) -> Iterator[str]:
    platform_sel = {
        "linux-64": {"linux64", "unix", "linux"},
        "linux-aarch64": {"aarch64", "unix", "linux"},
        "linux-ppc64le": {"ppc64le", "unix", "linux"},
        "osx-64": {"osx", "osx64", "unix"},
        "osx-arm64": {"arm64", "osx", "unix"},
        "win-64": {"win", "win64"},
    }

    # This code is adapted from conda-build
    sel_pat = re.compile(r"(.+?)\s*(#.*)?\[([^\[\]]+)\](?(2)[^\(\)]*)$")
    for line in content.splitlines(keepends=False):
        if line.lstrip().startswith("#"):
            continue
        m = sel_pat.match(line)
        if m:
            cond = m.group(3)
            if cond == platform or cond in platform_sel[platform]:
                yield line
        else:
            yield line


def parse_environment_file(spec_file: Path, platform: str) -> LockSpecification:
    with spec_file.open("r") as f:
        filtered_content = "\n".join(filter_platform_selectors(f.read(), platform=platform))
        env_yaml_data = yaml.safe_load(filtered_content)

    specs = [x for x in env_yaml_data["dependencies"] if isinstance(x, str)]
    channels = env_yaml_data.get("channels", [])

    return LockSpecification(specs=specs, channels=channels, platform=platform)


def _env_lock_conda():
    platforms = spec_platforms()
    new_lock_paths = [str(conda_lock_file(p)) for p in platforms]
    for lock_path in glob(str(conda_lock_file("*"))):
        if lock_path not in new_lock_paths:
            print(
                click.style("   lock:", fg="bright_white"),
                "Removing",
                click.style("Conda", fg="magenta"),
                "lock file",
                click.style(f"[{lock_path}]", fg="bright_white"),
                file=sys.stderr,
            )
            os.remove(lock_path)

    for platform in platforms:
        print(
            click.style("   lock:", fg="bright_white"),
            "Generating",
            click.style("Conda", fg="magenta"),
            "lock file for",
            click.style(platform, fg="cyan"),
            click.style(f"[{conda_lock_file(platform)}]", fg="bright_white"),
            file=sys.stderr,
        )
        lock_spec = parse_environment_file(spec_file(), platform)
        lock_contents = create_lockfile_from_spec(
            channels=lock_spec.channels,
            conda=system_exe(),
            spec=lock_spec,
            kind="explicit",
        )
        with open(conda_lock_file(platform), "w") as f:
            f.write("\n".join(lock_contents) + "\n")


def _run_pip_compile(requirements):
    pin_args = [
        sys.executable,
        "-m",
        "piptools",
        "compile",
        "-",
        "-o",
        "-",
        "--no-allow-unsafe",
        "--generate-hashes",
        "--no-header",
    ]
    res = subprocess.run(
        pin_args,
        input=requirements,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        encoding="utf-8",
    )
    if res.returncode != 0:
        print(res.stderr)
        exit(1)
    return res.stdout


def _env_lock_pip():
    requirements = spec_pip_requirements()
    if not requirements:
        if pip_lock_file().exists():
            print(
                click.style("   lock:", fg="bright_white"),
                "Removing",
                click.style("Pip", fg="magenta"),
                "lock file",
                click.style(f"[{pip_lock_file()}]", fg="bright_white"),
                file=sys.stderr,
            )
            os.remove(pip_lock_file())
        return

    print(
        click.style("   lock:", fg="bright_white"),
        "Generating",
        click.style("Pip", fg="magenta"),
        "lock file",
        click.style(f"[{pip_lock_file()}]", fg="bright_white"),
        file=sys.stderr,
    )
    lock = _run_pip_compile(requirements)

    lock_hash = hashlib.sha256(lock.encode("utf-8")).hexdigest()
    lock = f"# Generated by pip-compile.\n# env_hash: {lock_hash}\n\n{lock}"
    with open(pip_lock_file(), "w") as f:
        f.write(lock)


def env_lock(conda: bool = True, pip: bool = True):
    require_spec_file()

    if conda:
        _env_lock_conda()
    if pip:
        _env_lock_pip()


def _env_install_conda(prune: bool):
    prefix = env_prefix()
    lock_path = conda_lock_file()
    print(
        click.style("install:", fg="bright_white"),
        "Installing",
        click.style("Conda", fg="magenta"),
        "environment",
        click.style("<create>", fg="red") if prune else click.style("<update>", fg="green"),
        click.style(f"[{lock_path}]", fg="bright_white"),
        file=sys.stderr,
    )
    args = [
        "create" if prune or not prefix.exists() else "update",
        "--file",
        lock_path,
        "--prefix",
        prefix,
        "--yes",
    ]
    if not run_exe(args):
        click.secho(f"\nCould not install {lock_path} into {prefix}", fg="red", file=sys.stderr)
        exit(1)


def _env_install_pip():
    lock_path = pip_lock_file()
    print(
        click.style("install:", fg="bright_white"),
        "Installing",
        click.style("Pip", fg="magenta"),
        "packages",
        click.style(f"[{lock_path}]", fg="bright_white"),
        file=sys.stderr,
    )
    args = [
        env_python_exe(),
        "-m",
        "pip",
        "install",
        "-r",
        lock_path,
        "--no-deps",
        "--disable-pip-version-check",
        "--no-input",
        "--quiet",
    ]
    res = subprocess.run(args)
    if res.returncode != 0:
        print(res.stderr)
        exit(1)


def env_install(prune: Optional[bool] = None, force: bool = False, quiet: bool = False, show: bool = False):
    require_spec_file()

    old_pkgs = env_show(deps=True, only_return=True) if show and env_prefix().exists() else {}

    use_pip = bool(spec_pip_requirements())
    if not conda_lock_file().exists() or (use_pip and not pip_lock_file().exists()):
        env_lock()

    conda_hash = conda_lock_hash()
    conda_changed = conda_outdated(conda_hash)

    pip_hash = pip_lock_hash()
    pip_changed = pip_outdated(pip_hash)

    if prune is None:
        prune = (use_pip and conda_changed) or pip_changed

    # Conda
    if force or prune or conda_changed:
        _env_install_conda(prune)
        with open(env_prefix() / "conda_hash.txt", "w") as f:
            f.write(conda_hash)
    elif not quiet:
        print(
            click.style("install:", fg="bright_white"),
            click.style("Conda", fg="magenta"),
            "environment is already",
            click.style("up-to-date", fg="green"),
            file=sys.stderr,
        )

    # Pip
    pip_hash_path = env_prefix() / "pip_hash.txt"
    if pip_hash:
        if force or prune or pip_changed:
            _env_install_pip()
            with open(pip_hash_path, "w") as f:
                f.write(pip_hash)
        elif not quiet:
            print(
                click.style("install:", fg="bright_white"),
                click.style("Pip", fg="magenta"),
                "packages are already",
                click.style("up-to-date", fg="green"),
                file=sys.stderr,
            )
    elif pip_hash_path.exists():
        os.remove(pip_hash_path)

    if show:
        new_pkgs = env_show(deps=True, only_return=True)
        if new_pkgs != old_pkgs:
            print()

            for name, info in old_pkgs.items():
                if name not in new_pkgs:
                    print(
                        click.style("install:", fg="bright_white"),
                        "- Removed",
                        click.style(name.ljust(15), fg="red"),
                        f"({click.style(info['version'], fg='blue')})",
                        click.style(f"[{info['channel']}]", fg="bright_white"),
                        file=sys.stderr,
                    )

            for name, info in new_pkgs.items():
                pypi = info['channel'] == "pypi"
                name_str = click.style(name.ljust(15), fg="cyan" if pypi else "green")
                channel_str = click.style(f"[{info['channel']}]", fg="cyan" if pypi else "bright_white")
                if name not in old_pkgs:
                    print(
                        click.style("install:", fg="bright_white"),
                        "+   Added",
                        name_str,
                        f"({click.style(info['version'], fg='blue')})",
                        channel_str,
                        file=sys.stderr,
                    )
                    continue

                old_info = old_pkgs[name]
                if old_info != info:
                    print(
                        click.style("install:", fg="bright_white"),
                        "* Updated",
                        name_str,
                        f"({click.style(old_info['version'], fg='red')} => {click.style(info['version'], fg='blue')})",
                        channel_str,
                        file=sys.stderr,
                    )


def env_uninstall():
    run_exe(["env", "remove", "--prefix", env_prefix()])


def change_spec(*, add_pkgs: List[str], remove_pkgs: List[str], pip: bool, update: bool, install: Optional[bool],
                prune: Optional[bool], force: bool, show: bool):
    require_spec_file()
    spec_data, save_spec_file = edit_spec_file()

    def _dep_names(deps):
        return [pkg.split(" ")[0] if not isinstance(pkg, OrderedDict) else None for pkg in deps]

    deps = spec_data["dependencies"]
    dep_names = _dep_names(deps)

    def _add_pkg(pkg: str, pip: bool):
        if pip:
            pkg_info = pypi_pkg_info(pkg)
        else:
            pkg_info = conda_pkg_info(pkg, spec_data["channels"])

        name = pkg_info["name"]
        pkg = f"{name} >={pkg_info['version']}"
        channel = pkg_info["channel"]

        i = len(deps)
        if name in dep_names:
            i = dep_names.index(name)
            if deps[i] == pkg:
                return False
            deps.pop(i)

        deps.insert(i, pkg)
        dep_names.insert(i, name)

        name, ver = pkg.split()
        pkg_str = f"{click.style(name, fg='green')} ({click.style(ver, fg='blue')})"
        print(
            click.style("   spec:", fg="bright_white"),
            f"Added {pkg_str} to dependencies",
            click.style(f"[{channel}]", fg="bright_white"),
            file=sys.stderr,
        )
        return True

    def _remove_pkg(pkg: str):
        if pkg not in dep_names:
            return False

        i = dep_names.index(pkg)
        pkg = deps.pop(i)
        dep_names.pop(i)

        name, ver = pkg.split()
        pkg_str = f"{click.style(name, fg='green')} ({click.style(ver, fg='blue')})"
        print(click.style("   spec:", fg="bright_white"), f"Removed {pkg_str} from dependencies", file=sys.stderr)
        return True

    if pip:
        if "pip" not in dep_names:
            _add_pkg("pip", pip=False)
        pip_deps = None
        for spec in deps:
            if isinstance(spec, OrderedDict) and "pip" in spec:
                if not spec["pip"]:
                    spec["pip"] = []
                pip_deps = spec["pip"]
                break
        if pip_deps is None:
            deps.append(dict(pip=[]))
            pip_deps = deps[-1]["pip"]

        deps = pip_deps
        dep_names = _dep_names(deps)

    changed = False
    for pkg in add_pkgs:
        if _add_pkg(pkg, pip=pip):
            changed = True
    for pkg in remove_pkgs:
        if _remove_pkg(pkg):
            changed = True

    if not changed:
        if add_pkgs:
            print(click.style("   spec:", fg="bright_white"),
                  click.style("No new dependencies added", fg="yellow"),
                  file=sys.stderr)
        if remove_pkgs:
            print(click.style("   spec:", fg="bright_white"),
                  click.style("No dependencies removed", fg="yellow"),
                  file=sys.stderr)

    save_spec_file()
    if update:
        print(file=sys.stderr)
        env_lock(conda=not pip)

    if install is None:
        install = env_prefix().exists()

    prune = len(remove_pkgs) > 0 or prune
    if update and install:
        print(file=sys.stderr)
        env_install(prune=prune, force=force, show=show)


def env_show(query: List[str] = [], deps: bool = False, only_return: bool = False):
    out = run_exe(["list", "--prefix", env_prefix(), *query, "--json"])
    if not out:
        print("No results", file=sys.stderr)
        exit(1)
    res = json.loads(out)

    conda_names, pip_names = spec_package_names()
    data = {}
    for pkg_info in res:
        name, version, channel = pkg_info["name"], pkg_info["version"], pkg_info["channel"]
        if not deps and not (name in conda_names or name in pip_names):
            continue

        fg, warning = None, ""
        if channel == "pypi":
            if name in pip_names:
                fg = "cyan"
            else:
                warning = "WARNING: implicit pip dependency"
            if name in conda_names:
                warning = "WARNING: conda dependency overriden by pip"
        else:
            if name in conda_names:
                fg = "green"

        data[name] = {
            "version": version,
            "channel": channel,
        }
        if not only_return:
            name_fmt = click.style(name.ljust(20), fg=fg)
            version_fmt = click.style(version.ljust(12), fg="blue")
            channel_fmt = click.style(channel.ljust(14), fg="cyan" if channel == "pypi" else "bright_white")
            warning_str = click.style(warning.ljust(20), fg="yellow")

            line = f"{name_fmt} {version_fmt} {channel_fmt} {warning_str}"
            print(line)

    return data


def conda_search(pkg: str,
                 channels: Optional[List[str]] = None,
                 platform: Optional[str] = None) -> List[Dict[str, Any]]:
    channels = channels or spec_channels()
    args = []
    for c in channels:
        args.extend(["-c", c])
    if platform:
        args.extend(["--subdir", platform])

    out = run_exe(["search", pkg, *args, "--json"], check=False)
    if not out:
        print(f"Unable to query package through '{system_exe()}'", file=sys.stderr)
        exit(1)
    res = json.loads(out)
    if "error" in res:
        print(res["error"], file=sys.stderr)
        exit(1)

    if pkg not in res:
        print(f"Package '{pkg}' not found. Did you mean: {', '.join(sorted(res))}", file=sys.stderr)
        exit(1)

    info = res[pkg]
    for pkg_info in info:
        pkg_info["channel"] = pkg_info["channel"].split("/")[-2]
    return info


def conda_pkg_info(pkg: str, channels: Optional[List[str]] = None):
    return conda_search(pkg, channels)[-1]


def env_search(pkg: str, platform: Optional[str], limit: int):
    platforms = [platform] if platform else spec_platforms()

    for i, platform in enumerate(platforms, start=1):
        if i > 1:
            print()
        pkg_infos = conda_search(pkg, platform=platform)
        if limit > 0:
            pkg_infos = pkg_infos[-limit:]
        click.secho(f"# platform: {click.style(platform, bold=True)}", fg="cyan")
        if not pkg_infos:
            click.secho("No results", fg="yellow")
            exit(1)

        for j, pkg_info in enumerate(pkg_infos, start=1):
            bold = j == len(pkg_infos)
            name_fmt = click.style(pkg_info["name"].ljust(20), fg="green", bold=bold)
            version_fmt = click.style(pkg_info["version"].ljust(12), fg="blue", bold=bold)
            build_fmt = click.style(pkg_info["build"].ljust(16), fg="bright_white", bold=bold)
            channel_fmt = click.style(pkg_info["channel"].ljust(14), fg="bright_white", bold=bold)

            line = f"{name_fmt} {version_fmt} {build_fmt} {channel_fmt}"
            print(line)
